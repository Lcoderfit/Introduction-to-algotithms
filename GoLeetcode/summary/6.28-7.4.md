678. 有效的括号字符串.go
    令l,h分别为左括号可能数量的下限和上限;为什么不能如下：
        	l, h := 0, 0
        	for _, c := range s {
        		if c == '(' {
        			l++
        			h++
        		} else if c == '*' {
        			l--
        			h++
        		} else {
        			l--
        			h--
        		}
        		if h < 0 {
        			return false
        		}
        	}
        	return l <= 0
    而必须当l > 0时才能进行减1操作：
            l, h := 0, 0
            for _, c := range s {
                if c == '(' {
                    l++
                    h++
                } else if c == '*' {
                    if l > 0 {
                        l--
                    }
                    h++
                } else {
                    if l > 0 {
                        l--
                    }
                    h--
                }
                if h < 0 {
                    return false
                }
            }
            return l == 0
    因为括号具有有序匹配性（即如果是")("虽然有一个右括号和一个左括号，但是由于顺序不对则不匹配所以不行）；假设字符串s为"*("，那么如果用第一种方法，
    遇到'*', 则l，h更新为-1, 1; 然后遇到'(', l更新为-2， h更新为0， 则如果return l <= 0得到的结果就是错误的。因为"*("是不合法的；
    所以为了保证括号有序性，必须当l > 0时才能减1，
    
    方法二：索引栈(索引可以用于判断括号有序性问题)
    通过两个栈，如果遇到'(',则将其对应的索引压入栈1，如果遇到'*'，则将其索引压入栈2，如果遇到'）'，则先将栈1弹出，栈1为空则弹栈2，最后如果
    栈1不为空，则比较栈1的顶部和栈2的顶部元素，如果栈1顶部索引大于栈2，则说明'('在'*'的右边，违反括号有序匹配性
    
    方法三：潮汐法（遇到'('相当于起潮，遇到')'相当于退潮，变量h记录潮汐高度，起潮时+1， 退潮时-1，潮汐不可能比0小，所以当h<0则返回False）
    此题因为有'*',既可以当作起潮，又可以当作退潮，又可以无视（空字符），所以需要额外用两个变量来分别表示'*'的总数，和可以表示')'的总数
    
    