678. 有效的括号字符串.go
    令l,h分别为左括号可能数量的下限和上限;为什么不能如下：
        	l, h := 0, 0
        	for _, c := range s {
        		if c == '(' {
        			l++
        			h++
        		} else if c == '*' {
        			l--
        			h++
        		} else {
        			l--
        			h--
        		}
        		if h < 0 {
        			return false
        		}
        	}
        	return l <= 0
    而必须当l > 0时才能进行减1操作：
            l, h := 0, 0
            for _, c := range s {
                if c == '(' {
                    l++
                    h++
                } else if c == '*' {
                    if l > 0 {
                        l--
                    }
                    h++
                } else {
                    if l > 0 {
                        l--
                    }
                    h--
                }
                if h < 0 {
                    return false
                }
            }
            return l == 0
    因为括号具有有序匹配性（即如果是")("虽然有一个右括号和一个左括号，但是由于顺序不对则不匹配所以不行）；假设字符串s为"*("，那么如果用第一种方法，
    遇到'*', 则l，h更新为-1, 1; 然后遇到'(', l更新为-2， h更新为0， 则如果return l <= 0得到的结果就是错误的。因为"*("是不合法的；
    所以为了保证括号有序性，必须当l > 0时才能减1，
    
    方法二：索引栈(索引可以用于判断括号有序性问题)
    通过两个栈，如果遇到'(',则将其对应的索引压入栈1，如果遇到'*'，则将其索引压入栈2，如果遇到'）'，则先将栈1弹出，栈1为空则弹栈2，最后如果
    栈1不为空，则比较栈1的顶部和栈2的顶部元素，如果栈1顶部索引大于栈2，则说明'('在'*'的右边，违反括号有序匹配性
    
    方法三：潮汐法（遇到'('相当于起潮，遇到')'相当于退潮，变量h记录潮汐高度，起潮时+1， 退潮时-1，潮汐不可能比0小，所以当h<0则返回False）
    此题因为有'*',既可以当作起潮，又可以当作退潮，又可以无视（空字符），所以需要额外用两个变量来分别表示'*'的总数，和可以表示')'的总数
    

368. 最大整除子集.go
    对于最值问题，一般有两种问法，一种是最长序列有多长，一种是最长序列是什么； 第二种情况一般比第一种情况需要多处理一些东西；
    可以先求出最长序列有多长，然后再根据最长序列去反推最长序列是什么；
    也可以当dp[i]的值变大时，手动更新最长序列；
    
    	if len(nums) == 0 {
    		return nil
    	}
    	sort.Ints(nums)
    
    	// dp[i]表示以nums[i]结尾的最长[0..i-1]中最长的整除子集长度
    	dp := make([]int, len(nums))
    
    	// 正整数
    	maxSize, maxVal := 1, nums[0]
    	for i := 0; i < len(nums); i++ {
    		// 每个dp初始化为1，因为至少都有一个，就是nums[i]本身
    		dp[i] = 1
    		for j := 0; j < i; j++ {
    			if nums[i]%nums[j] == 0 {
    				dp[i] = Max(dp[i], dp[j]+1)
    			}
    		}
    		if dp[i] > maxSize {
    			maxSize, maxVal = dp[i], nums[i]
    		}
    	}
    
    	// 先求出最长整除子集长度和整除子集最大值，再逆序遍历，求出整除子集的元素
    	result := make([]int, 0)
    	for i := len(nums) - 1; i >= 0 && maxSize > 0; i-- {
    		if (dp[i] == maxSize) && (maxVal%nums[i] == 0) {
    			maxSize--
    			maxVal = nums[i]
    			result = append(result, nums[i])
    		}
    	}
    	return result