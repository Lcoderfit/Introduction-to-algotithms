279. 完全平方数.go
// 枚举动态规划，dp[i] = Min(dp[i], dp[i-k]+1) (k: [1, 4, 9, .... ], k为枚举值， k为根号n的向下取整值)

416. 分割等和子集.go
分割等和这种问题，一般都是取与不取的问题，可以转换为0-1背包进行处理
0-1背包问题，dp[i][j]表示取到第i个的时候所求的值为j

解决dp问题时，默认将dp的长和宽扩充一个长度


131. 分割回文串.go
回溯的套路：
	dfs = func(i int) {
		if i == n {
			// 由于将splits多次压入ans时，只是将地址存入ans中，所以每次都需要创建一个新的slice
			ans = append(ans, append([]string{}, splits...))
			return
		}
		for j := i; j < n; j++ {
			// 如果s[i...j]是一个回文串，则向前迈出一步，否则回溯将splits恢复原样
			if dp[i+1][j+1] {
				splits = append(splits, s[i:j+1])
				dfs(j + 1)
				// 去除末尾元素（回溯一步）
				splits = splits[:len(splits)-1]
			}
		}
	}