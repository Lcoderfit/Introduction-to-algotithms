279. 完全平方数.go
// 枚举动态规划，dp[i] = Min(dp[i], dp[i-k]+1) (k: [1, 4, 9, .... ], k为枚举值， k为根号n的向下取整值)

416. 分割等和子集.go
分割等和这种问题，一般都是取与不取的问题，可以转换为0-1背包进行处理
0-1背包问题，dp[i][j]表示从前i个元素中取某些元素使总和为j

dp[i][j]: 在背包问题中i一般表示位置，j一般表示值

解决dp问题时，默认将dp的长和宽扩充一个长度

	for i := 0; i < len(nums); i++ {
		// 需要倒序动规，因为如果顺序动态规划，dp[j-nums[i]]会先被更新，保存的就不是上一次循环的结果，所以得到的dp[j]也就不是这一次循环的结果
		// 倒序动规，dp[j-nums[i]]保存的就是上一次循环的结果
		for j := target; j >= nums[i]; j-- {
			dp[j] = dp[j] || dp[j-nums[i]]
		}
	}
	
*****************
大发现,背包问题中,例如使用dp[i][j]表示从前i个元素中取某些元素使总和为j, 则dp[i][j]只与dp[i-1][j]或dp[i-1][j-k]有关系,换句话说:
dp[i][x1]表示当前层的dp值,而dp[i-1][x2]表示上一次循环的dp值,计算当前层需要上一层的辅助

如果我需要优化空间,将二维改成一维,如果顺序遍历,则dp[i-1]会比dp[i]先更新,当计算dp[i]时使用的dp[i-1]保存的已不再是上一次循环的dp值,
如果我逆序遍历,则先计算dp[i],此时dp[i]会用到dp[i-1],这个时候dp[i-1]没有被更新,保存的正是上一次循环的值

总结:背包问题,内层循环可以使用倒序遍历法进行dp降维; 初始化dp切片时,默认扩一个维度,因为dp[i][j]中的j牵涉到值的计算,j如果等于当前值操作会更方便
01背包常规解法,顺序dp用二维,改成逆序遍历后可以只适用一个维,
二维背包,常规解决,顺序dp用三维slice, 可以将背包值的两个维度作为二维slice, 然后逆序遍历

倒序循环时，从目标值开始（或者最大容量），到nums[i]（即第i个位置的元素值）结束;
例如：假设目标值为target，当前位置元素为nums[i], 则dp定义的大小为dp := make([]int, target+1)
注意：由于是求方法数的总和，所以每循环一层，需要加上上一层循环的结果,用“+=”
for j := target; j >= nums[i]; j-- {
    dp[j] += dp[j-nums[i]]
}
初始化：dp[i]表示取数和为i的方法总数，dp[0]即表示取数和为0的方法数，只有一种方法，即一个也不取
*********************

131. 分割回文串.go
回溯的套路：
	dfs = func(i int) {
		if i == n {
			// 由于将splits多次压入ans时，只是将地址存入ans中，所以每次都需要创建一个新的slice
			ans = append(ans, append([]string{}, splits...))
			return
		}
		for j := i; j < n; j++ {
			// 如果s[i...j]是一个回文串，则向前迈出一步，否则回溯将splits恢复原样
			if dp[i+1][j+1] {
				splits = append(splits, s[i:j+1])
				dfs(j + 1)
				// 去除末尾元素（回溯一步）
				splits = splits[:len(splits)-1]
			}
		}
	}
	
