1049. 最后一块石头的重量 II.go
    首先，石头问题可以转换为背包问题，题目中说取两个石头然后相减成为新石头，操作到最后剩下的一块石头的重量，那么其实可以转换为在石头重量前添加+/-
    最终的结果即为（带+的石头值 减去 带-的石头值）的最小值，进而可以转换为取这i堆石头中，值不超过sum/2的最大值
    dp[i][j]即为在前i个石头中取，总和不超过j的可取的最大值是多少：
        func lastStoneWeightII(stones []int) int {
            if stones == nil || len(stones) == 0 {
                return 0
            }
            sum := 0
            for _, v := range stones {
                sum += v
            }
            target := sum / 2
            m := len(stones)
        
            dp := make([][]int, m+1)
            for i := range dp {
                dp[i] = make([]int, target+1)
            }
        
            for i := 1; i <= m; i++ {
                for j := 1; j <= target; j++ {
                    dp[i][j] = dp[i-1][j]
                    if j >= stones[i-1] {
                        dp[i][j] = Max(dp[i][j], dp[i-1][j-stones[i-1]]+stones[i-1])
                    }
                }
            }
            return sum - 2*dp[m][target]
        }
        
    空间优化：
        func lastStoneWeightII1(stones []int) int {
            if stones == nil || len(stones) == 0 {
                return 0
            }
            sum := 0
            for _, v := range stones {
                sum += v
            }
            target := sum / 2
            m := len(stones)
        
            // 因为总和最大只有target，所以dp最大索引为target即可
            dp := make([]int, target+1)
            for i := 1; i <= m; i++ {
                // 1.计算当前层时，需要使用上一层的数据，所以需要逆序遍历
                // 2.如果j < stones[i-1],则dp[i][j] = dp[i-1][j],即当前层dp[j]等于上一层的dp[j](令dp[j]的值不变即可), 所以for循环条件设为j >= stones[i-1]
                // 3.如果j >= stones[i-1], dp[i][j] = Max(dp[i][j], dp[i-1][j-stones[i-1]]+stones[i-1]) (当前元素取与不取的问题);
                // 即当前层dp[j]取上一层dp[j]与dp[j-stones[i-1]]+stones[i-1]的最大值
                for j := target; j >= stones[i-1]; j-- {
                    dp[j] = Max(dp[j], dp[j-stones[i-1]]+stones[i-1])
                }
            }
            return sum - 2*dp[target]
        }
        
435. 无重叠区间.go
    当要求什么最小时，如果无法直观的找到思路，不防设想一下当什么情况下会最大，然后根据最大反推到最小;
    例如要求删除的最少元素个数，使得区间为无重叠区间，首先可以确定切片总长度确定为n，如果求到最长无重叠区间的长度x，然后用n-x不就是删除的最少元素吗
    
    总结：求删除的最少元素个数，可以转换为求某种最长序列
        func eraseOverlapIntervals(intervals [][]int) int {
            if intervals == nil || len(intervals) == 0 {
                return 0
            }
        
            // 通过左区间排序，然后根据前面的元素的右边界是否小于等于 后面元素的左边界来判断是否是可以构成符合要求的区间
            sort.Slice(intervals, func(i, j int) bool {
                return intervals[i][0] < intervals[j][0]
            })
        
            n := len(intervals)
            // dp[i]表示以列表i结尾的最长的符合要求的区间长度
            dp := make([]int, n+1)
            // 注意初始化条件，区间长度至少为1，即当前的元素
            for i := range dp {
                dp[i] = 1
            }
        
            // 区间dp
            for i := 1; i <= n; i++ {
                for j := 1; j < i; j++ {
                    if intervals[j-1][1] <= intervals[i-1][0] {
                        dp[i] = Max(dp[i], dp[j]+1)
                    }
                }
            }
            return n - dp[n]
        }