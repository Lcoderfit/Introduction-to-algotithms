1884. 鸡蛋掉落-两枚鸡蛋.go
    注意两点，第一点：题目中变换的状态（作为dp时的维度）; 
    第二点：例如有两个鸡蛋，则你需要大胆假设由两个鸡蛋变为1个鸡蛋时候的状态变换情况，分类讨论，如抛第一个鸡蛋的时候有两种
    状态，即碎与不碎，碎了的情况下，1个鸡蛋与2个鸡蛋之间的关系式，不碎的情况下，1个鸡蛋与2个鸡蛋的关系式
    
        dp := make([][]int, 3)
        for i := range dp {
            dp[i] = make([]int, n+1)
            for j := range dp[i] {
                dp[i][j] = math.MaxInt32
            }
        }
        dp[1][0], dp[2][0] = 0, 0
        // 如果只剩一个鸡蛋，需要确保一定能测出来哪一层刚好能摔碎，则必须从第一层开始一层一层往上试,
        // 所以对于i层楼，最少需要试i次才能试出来（为什么是i不是i-1，因为题目要求高于楼层f(0<=f<=n)的任何楼层都会碎）
        for i := 1; i <= n; i++ {
            dp[1][i] = i
        }
    
        // dp[i][j]表示有i个鸡蛋，测试j层楼一定能找到f的所需要的最少操作次数
        for j := 1; j <= n; j++ {
            for k := 1; k <= j; k++ {
                dp[2][j] = Min(Max(dp[1][k-1], dp[2][j-k])+1, dp[2][j])
            }
        }
    
    空间优化：由于dp[1][k-1]就等于k-1，所以原dp等式可以替换为： dp[2][i] = Min(Max(k-1, dp[2][i-k])+1, dp[2][i])；
        由此可见当前的dp只与当前层有关，可以进行降维: 设dp[i]表示对于i层楼，一定能测出鸡蛋不碎的临界楼层所需的最少次数;
        那么假设当前有两个鸡蛋，先拿一个鸡蛋来试，两种情况，第一种情况鸡蛋在k层碎了，则剩下一颗鸡蛋必须从第一层逐层试到第k-1层（dp[i] = k-1 + 1）
        第二种情况，鸡蛋没碎，则接下来需要用两个鸡蛋来试i-k层楼，即dp[i] = dp[i-k] + 1
        所以： dp[i] = Min(dp[i], Max(k-1, dp[i-k])+1)
    
    注意： 因为需要计算当j属于[1~i]时dp[i]的最小值，所以dp[i]初始值应该设置为最大值，不然结果就总是0了

    更简便的数学法；https://blog.csdn.net/weixin_42069523/article/details/90273892
        if n == 0 {
            return 0
        }
        return int(math.Ceil((math.Sqrt(float64(8*n+1)) - 1) / 2))