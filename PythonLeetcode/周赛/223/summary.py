"""
一、1167. 连接棒材的最低费用.py
遇到这种需要排序，然后取最小的两个或者最大的两个数进行操作得到一个结果，这个结果又要与剩下的元素进行同样操作的时候，可以采用堆的数据结构简化

二、1564. 把箱子放进仓库里 I.py
1.当有双指针时，其中一个指针必须遍历完所有元素，则可将while替换为for循环
2.这个跟分发饼干有些类似，关键在于将高低不同的warehouse转换为非递增的序列
例如 3 5 4 2 3， 后一块墙能通过多大的板子受到前一块板子的限制，也就是能通过当前墙面的最大板子为min(前一块墙高度，当前墙高度)
所以可以通过从左到右遍历，两个相邻的墙对比，如果后一块墙要高于前一快，则将后一块改成跟前一块一样高就行,
再对boxes进行排序，这样warehouse和boxes都是有序的，两个有序序列的分发问题，就是分发饼干了，用双指针即可。

三、870. 优势洗牌.py
方法1： 排序+贪心 （单指针插入法）: 用一个索引变量来控制元素插入位置,插入一个则变量自增1,如果遇到插入位置已经有元素,
则再向右移动直到找到右边第一个未插入元素的位置

方法2： 排序+贪心 （双表拆合法）： 将两种不同性质的元素分拆到两个列表里，然后再根据条件选择其中的一个元素放入结果列表中合并

四、342. 4的幂.py
取模运算定律

五、389. 找不同.py
相同字符进行异或运算则抵消为0，所以如果s比t少了一个字符，则直接将两个字符串的所有字符进行异或运算即可

六、405. 数字转换为十六进制数.py
hex_str = "0123456789abcdef"； 可以使用这个对十进制数转换为十六进制数进行映射简化操作

七、面试题 17.10. 主要元素.py
摩尔投票法：
1.判断票数是否为0，如果为0则取当前元素为结果
2.判断当前结果是否与当前元素相等，相等则将票数+1，否则-1

八、面试题 05.06. 整数转换.py
Python3占用字节数

九、751. IP 到 CIDR.py
            start & -start算出来的是start的二进制表示中，最右边的一个“1”及该“1”右边的所有0
            用于构建子网的位必须都为0，否则不能用于构建本题中的ip
            能够用于构建子网的位不能比n的二进制表示的长度要大，n二进制表示为100，则用于构建子网的位必须 < 3
            而由于start & (-start）除了包含用于构建子网的“0”，还包含start二进制表示中最右边的一个1，
            故(start & -start).bit_length() <= n.bit_length(), 所以在符合要求情况下，最长的用于构建子网的位为:
            min((start & -start).bit_length(), n.bit_length()) - 1
            mask = 32 - （min((start & -start).bit_length(), n.bit_length()) - 1） =》
            33 - min((start & -start).bit_length(), n.bit_length()

十、1356. 根据数字二进制下 1 的数目排序.py
bin(x).count("1")
"""